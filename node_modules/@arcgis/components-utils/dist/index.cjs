"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Deferred: () => Deferred,
  addLTRMark: () => addLTRMark,
  camelToHuman: () => camelToHuman,
  camelToKebab: () => camelToKebab,
  capitalize: () => capitalize,
  classes: () => classes,
  closestElement: () => closestElement,
  createFilterExpression: () => createFilterExpression,
  debounce: () => debounce,
  defaultLocale: () => defaultLocale,
  devToolsAwareTimeout: () => devToolsAwareTimeout,
  extractMinorVersion: () => extractMinorVersion,
  fetchT9nStringsBundle: () => fetchT9nStringsBundle,
  focusElement: () => focusElement,
  generateGuid: () => generateGuid,
  getElementAttribute: () => getElementAttribute,
  getElementDir: () => getElementDir,
  getElementLocales: () => getElementLocales,
  getElementTheme: () => getElementTheme,
  getPreamble: () => getPreamble,
  hasSameOrigin: () => hasSameOrigin,
  identity: () => identity,
  isEsriInternalEnv: () => isEsriInternalEnv,
  isNotNull: () => isNotNull,
  isNotUndefined: () => isNotUndefined,
  isURL: () => isURL,
  kebabToPascal: () => kebabToPascal,
  mappedFind: () => mappedFind,
  normalizeLocale: () => normalizeLocale,
  observeAncestorsMutation: () => observeAncestorsMutation,
  quoteString: () => quoteString,
  safeAsyncCall: () => safeAsyncCall,
  safeCall: () => safeCall,
  setFocusOnElement: () => setFocusOnElement,
  setValuesInString: () => setValuesInString,
  startLocaleObserver: () => startLocaleObserver,
  supportedLocales: () => supportedLocales,
  uncapitalize: () => uncapitalize
});
module.exports = __toCommonJS(src_exports);

// src/array-utils.ts
function mappedFind(array, callback) {
  for (let i = 0; i < array.length; i++) {
    const value = callback(array[i], i);
    if (value != null) {
      return value ?? void 0;
    }
  }
  return;
}

// src/css-utils.ts
function classes(...classes2) {
  const effectiveClasses = [];
  for (let i = 0; i < classes2.length; i++) {
    const arg = classes2[i];
    if (typeof arg === "string") {
      effectiveClasses.push(arg);
    } else if (Array.isArray(arg)) {
      effectiveClasses.push.apply(effectiveClasses, arg);
    } else if (typeof arg === "object") {
      for (const prop in arg) {
        if (arg[prop]) {
          effectiveClasses.push(prop);
        }
      }
    }
  }
  const className = effectiveClasses.join(" ");
  effectiveClasses.length = 0;
  return className;
}

// src/deferred.ts
var Deferred = class {
  /**
   * Resolves the promise.
   * @param value The value to resolve the promise with.
   */
  resolve(_value) {
  }
  /**
   * Rejects the promise.
   */
  reject(_error) {
  }
  /**
   * Creates a new deferred promise.
   */
  constructor() {
    this.promise = new Promise((resolve, reject) => {
      this.resolve = resolve;
      this.reject = reject;
    });
  }
};

// src/dom.ts
function inTargetElement(element, targetElement) {
  let currentElement = element;
  while (currentElement) {
    if (currentElement === targetElement) {
      return true;
    }
    if (!currentElement.parentNode) {
      return false;
    }
    if (currentElement.parentNode instanceof ShadowRoot) {
      currentElement = currentElement.parentNode.host;
    } else {
      currentElement = currentElement.parentNode;
    }
  }
  return false;
}
function observeAncestorsMutation(element, attributeFilter, callback) {
  const { subscribe } = observe(attributeFilter);
  return subscribe((mutations) => {
    const matched = mutations.some((mutation) => inTargetElement(element, mutation.target));
    if (matched) {
      callback();
    }
  });
}
var observers = {};
function observe(attributeFilter) {
  const attributes = attributeFilter.join(",");
  const previousObserver = observers[attributes];
  if (previousObserver !== void 0) {
    return previousObserver;
  }
  const subscribers = /* @__PURE__ */ new Set();
  const mutationObserver = new MutationObserver((mutations) => subscribers.forEach((callback) => callback(mutations)));
  if (globalThis.document) {
    mutationObserver.observe(document.documentElement, {
      attributes: true,
      attributeFilter,
      subtree: true
    });
  }
  const observer = {
    subscribe(callback) {
      subscribers.add(callback);
      return () => {
        subscribers.delete(callback);
        if (subscribers.size === 0) {
          mutationObserver.disconnect();
          observers[attributes] = void 0;
        }
      };
    }
  };
  observers[attributes] = observer;
  return observer;
}
function closestElement(base, selector) {
  let currentElement = base;
  while (currentElement) {
    const element = currentElement.closest?.(selector);
    if (element) {
      return element;
    }
    const rootElement = currentElement.getRootNode?.();
    if (rootElement === globalThis.document) {
      return null;
    }
    currentElement = rootElement.host;
  }
  return null;
}
function getElementTheme(base) {
  const themeElement = closestElement(base, ":is(.calcite-mode-light, .calcite-mode-dark)");
  return themeElement?.classList.contains("calcite-mode-dark") ? "dark" : "light";
}
function getElementDir(el) {
  return getElementAttribute(el, "dir", "ltr");
}
function getElementAttribute(el, prop, fallbackValue) {
  const closest = closestElement(el, `[${prop}]`);
  return closest?.getAttribute(prop) ?? fallbackValue;
}
function isElement(ref) {
  return ref.nodeType === Node.ELEMENT_NODE;
}
function hasSetFocus(ref) {
  return typeof ref.setFocus === "function";
}
function setFocus(ref, selector = "") {
  if (!isElement(ref)) {
    return false;
  }
  if (ref.matches(selector)) {
    if (hasSetFocus(ref)) {
      setTimeout(() => void ref.setFocus(), 0);
    }
    return true;
  }
  for (const child of ref.children) {
    if (setFocus(child, selector)) {
      return true;
    }
  }
  const shadowRoot = ref.shadowRoot;
  if (shadowRoot) {
    for (const child of shadowRoot.children) {
      if (setFocus(child, selector)) {
        return true;
      }
    }
  }
  return false;
}
async function focusElement(el) {
  if (el == null) {
    return;
  }
  if (hasSetFocus(el)) {
    await el.setFocus();
  } else {
    el.focus();
  }
}
function setFocusOnElement(ref, selector) {
  if (!ref?.shadowRoot) {
    return;
  }
  if (ref.hasAttribute("hydrated") || ref.hasAttribute("calcite-hydrated")) {
    setFocus(ref, selector);
    return;
  }
  void Promise.resolve(ref.componentOnReady?.()).then(() => setFocus(ref, selector));
}

// src/errors.ts
function isEsriInternalEnv() {
  return typeof globalThis.process === "object" && !!process.env.ESRI_INTERNAL;
}
function safeCall(callback, thisContext, ...rest) {
  try {
    return callback?.call(thisContext, ...rest);
  } catch (error) {
    console.error(error, callback);
  }
  return void 0;
}
async function safeAsyncCall(callback, thisContext, ...rest) {
  try {
    const result = callback?.call(thisContext, ...rest);
    return result instanceof Promise ? await result : result;
  } catch (error) {
    console.error(error, callback);
  }
  return void 0;
}

// src/guid.ts
function gen(count) {
  let out = "";
  for (let i = 0; i < count; i++) {
    out += ((1 + Math.random()) * 65536 | 0).toString(16).substring(1);
  }
  return out;
}
function generateGuid() {
  return [gen(2), gen(1), gen(1), gen(1), gen(3)].join("-");
}

// src/intl.ts
var supportedLocalesArray = [
  "ar",
  "bg",
  "bs",
  "ca",
  "cs",
  "da",
  "de",
  "el",
  "en",
  "es",
  "et",
  "fi",
  "fr",
  "he",
  "hr",
  "hu",
  "id",
  "it",
  "ja",
  "ko",
  "lt",
  "lv",
  "nl",
  "nb",
  "no",
  "pl",
  "pt-BR",
  "pt-PT",
  "ro",
  "ru",
  "sk",
  "sl",
  "sr",
  "sv",
  "th",
  "tr",
  "uk",
  "vi",
  "zh-CN",
  "zh-HK",
  "zh-TW"
];
var supportedLocales = /* @__PURE__ */ new Set(supportedLocalesArray);
var defaultLocale = "en";
var localeEquivalencies = {
  // We use `pt-PT` as it will have the same translations as `pt`, which has no corresponding bundle
  pt: "pt-PT",
  // We support both 'nb' and 'no' (BCP 47) for Norwegian but only `no` has corresponding bundle
  nb: "no",
  // We use `zh-CN` as base translation for chinese locales which has no corresponding bundle.
  zh: "zh-CN"
};
async function fetchT9nStringsBundle(locale, assetsPath, prefix = "") {
  const path = `${assetsPath}/${prefix}`;
  const filePath = `${path}${locale}.json`;
  t9nStringsCache[filePath] ?? (t9nStringsCache[filePath] = fetchBundle(locale, path));
  return await t9nStringsCache[filePath];
}
var t9nStringsCache = {};
async function fetchBundle(locale, path) {
  const filePath = `${path}${locale}.json`;
  try {
    const response = await fetch(filePath);
    if (response.ok) {
      return await response.json();
    }
  } catch (error) {
    if (process.env.NODE_ENV !== "production") {
      const is404ViteFallback = String(error).includes(`Unexpected token '<', "<!doctype "... is not valid JSON`);
      if (is404ViteFallback) {
        console.error(`[404] Localization strings not found at ${filePath}`);
      } else {
        console.error(`Error fetching localization strings at ${filePath}`, error);
      }
    } else {
      console.error(error);
    }
    return {};
  }
  if (locale === defaultLocale) {
    return {};
  }
  return await fetchBundle(defaultLocale, path);
}
function getElementLocales(element) {
  const lang = getElementAttribute(element, "lang", globalThis.navigator?.language || defaultLocale);
  return { lang, t9nLocale: normalizeLocale(lang) };
}
function normalizeLocale(locale) {
  const [rawLanguageCode, regionCode] = locale.split("-");
  const languageCode = rawLanguageCode.toLowerCase();
  let normalizedLocale = languageCode;
  if (regionCode) {
    normalizedLocale = `${languageCode}-${regionCode.toUpperCase()}`;
  }
  normalizedLocale = localeEquivalencies[normalizedLocale] ?? normalizedLocale;
  if (supportedLocales.has(normalizedLocale)) {
    return normalizedLocale;
  }
  if (regionCode) {
    return normalizeLocale(languageCode);
  }
  return defaultLocale;
}
function startLocaleObserver(element, getAssetsPath, onUpdated, assetName) {
  let result = void 0;
  const callback = () => void updateComponentLocaleState(element, getAssetsPath(), assetName).then((newResult) => {
    if (result?.lang !== newResult.lang || result.t9nLocale !== newResult.t9nLocale || result.t9nStrings !== newResult.t9nStrings) {
      onUpdated(newResult);
    }
    result = newResult;
  }).catch(console.error);
  queueMicrotask(callback);
  return observeAncestorsMutation(element, ["lang"], callback);
}
async function updateComponentLocaleState(element, assetsPath, assetName = element.tagName.toLowerCase().split("-").slice(1).join("-")) {
  const { lang, t9nLocale } = getElementLocales(element);
  const t9nAssetsPath = `${assetsPath}/${assetName}/t9n`;
  const prefix = `messages.`;
  const t9nStrings = (
    // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
    assetName === null ? {} : await fetchT9nStringsBundle(t9nLocale, t9nAssetsPath, prefix)
  );
  return { lang, t9nLocale, t9nStrings };
}

// src/preamble.ts
var blurb = "All material copyright Esri, All Rights Reserved, unless otherwise specified.\nSee https://js.arcgis.com/{minorVersion}/esri/copyright.txt for details.\nv{version}";
var extractMinorVersion = (version) => {
  const [major, minor] = version.split(".");
  return `${major}.${minor}`;
};
var getPreamble = (version) => blurb.replace("{minorVersion}", extractMinorVersion(version)).replace("{version}", version);

// src/strings.ts
var doubleQuote = '"';
var singleQuote = "'";
function repeatString(value, n) {
  return new Array(n + 1).join(value);
}
function quoteString(value) {
  let quote = doubleQuote;
  let alternateQuote = singleQuote;
  const avoidEscape = value.includes(quote) && !value.includes(alternateQuote);
  if (avoidEscape) {
    alternateQuote = doubleQuote;
    quote = singleQuote;
  }
  const alternateEscape = new RegExp(`(^|[^\\\\])((?:\\\\{2})*)((?:\\\\${alternateQuote})+)`, "gu");
  value = value.replace(
    alternateEscape,
    (_, boundaryChar, leadingEscapedSlashes, escapedQuoteChars) => (
      // We divide the escapedQuoteChars by 2 since there are 2 characters in each escaped part ('\\"'.length === 2)
      boundaryChar + leadingEscapedSlashes + repeatString(alternateQuote, escapedQuoteChars.length / 2)
    )
  );
  const quoteEscape = new RegExp(`(^|[^\\\\])((?:\\\\{2})*)(${quote}+)`, "gu");
  value = value.replace(
    quoteEscape,
    (_, boundaryChar, leadingEscapedSlashes, quoteChars) => boundaryChar + leadingEscapedSlashes + repeatString(`\\${quote}`, quoteChars.length)
  );
  return quote + value + quote;
}
function createFilterExpression(filterWord) {
  const sanitizedWord = filterWord ? filterWord.replaceAll(/[-[\]/{}()*+?.\\^$|]/gu, "\\$&") : "^.*$";
  return new RegExp(sanitizedWord, "i");
}
function setValuesInString(message, values = {}) {
  return (message ?? "").replace(/\{(?<valueName>.*?)\}/gu, (match, valueName) => values[valueName] ?? match);
}
function addLTRMark(value) {
  return `\u200E${value ?? ""}\u200E`;
}

// src/text.ts
var kebabToPascal = (string) => string.split("-").map(capitalize).join("");
var camelToKebab = (string) => string.replace(upperBeforeLower, (upper, remainder) => `${remainder === 0 ? "" : "-"}${upper.toLowerCase()}`);
var upperBeforeLower = /[A-Z]+(?![a-z])|[A-Z]/gu;
var capitalize = (string) => string.charAt(0).toUpperCase() + string.slice(1);
var uncapitalize = (string) => string.charAt(0).toLowerCase() + string.slice(1);
var camelToHuman = (string) => capitalize(string.replace(upperBeforeLower, (upper, remainder) => `${remainder === 0 ? "" : " "}${upper}`));

// src/timeouts.ts
function devToolsAwareTimeout(callback, timeout) {
  const interval = timeout > longTimeoutThreshold ? longTimeoutInterval : timeout / shortTimeoutIntervals;
  let elapsed = 0;
  const reference = setInterval(() => {
    elapsed += interval;
    if (elapsed >= timeout) {
      clearInterval(reference);
      callback();
    }
  }, interval);
  return reference;
}
var longTimeoutThreshold = 4e3;
var longTimeoutInterval = 2e3;
var shortTimeoutIntervals = 4;

// src/type-guards.ts
function isNotNull(item) {
  return item !== null;
}
function isNotUndefined(item) {
  return item !== void 0;
}

// src/types.ts
var identity = (value) => value;

// src/ui.ts
function debounce(func, waitFor = 100) {
  let timeout;
  return (...args) => {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, waitFor);
  };
}

// src/url.ts
function hasSameOrigin(url1, url2, ignoreProtocol = false) {
  if (!url1 || !url2) {
    return false;
  }
  const url1Obj = new URL(url1);
  const url2Obj = new URL(url2);
  if (!ignoreProtocol && url1Obj.protocol !== url2Obj.protocol) {
    return false;
  }
  if (url1Obj.host == null || url2Obj.host == null) {
    return false;
  }
  return url1Obj.host.toLowerCase() === url2Obj.host.toLowerCase() && url1Obj.port === url2Obj.port;
}
function isURL(url) {
  try {
    new URL(url);
    return true;
  } catch (e) {
    return false;
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Deferred,
  addLTRMark,
  camelToHuman,
  camelToKebab,
  capitalize,
  classes,
  closestElement,
  createFilterExpression,
  debounce,
  defaultLocale,
  devToolsAwareTimeout,
  extractMinorVersion,
  fetchT9nStringsBundle,
  focusElement,
  generateGuid,
  getElementAttribute,
  getElementDir,
  getElementLocales,
  getElementTheme,
  getPreamble,
  hasSameOrigin,
  identity,
  isEsriInternalEnv,
  isNotNull,
  isNotUndefined,
  isURL,
  kebabToPascal,
  mappedFind,
  normalizeLocale,
  observeAncestorsMutation,
  quoteString,
  safeAsyncCall,
  safeCall,
  setFocusOnElement,
  setValuesInString,
  startLocaleObserver,
  supportedLocales,
  uncapitalize
});
