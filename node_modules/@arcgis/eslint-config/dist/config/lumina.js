import {
  lumina_default
} from "../chunk-IOYJQSVP.js";
import "../chunk-25QTQ7LS.js";

// src/config/storybook.ts
import eslintPluginStorybook from "eslint-plugin-storybook";
var storybookConfig = [
  {
    ignores: ["**/storybook-static*"]
  },
  ...eslintPluginStorybook.configs["flat/recommended"].map((config) => ({
    ...config,
    files: ["**/*.stories.@(ts|tsx)"]
  })),
  ...eslintPluginStorybook.configs["flat/addon-interactions"].map((config) => ({
    ...config,
    files: ["**/*.stories.@(ts|tsx)"]
  })),
  ...eslintPluginStorybook.configs["flat/csf-strict"].map((config) => ({
    ...config,
    files: ["**/*.stories.@(ts|tsx)"]
  })),
  {
    files: ["**/*.stories.@(ts|tsx)"],
    rules: {
      // Redundant with https://typescript-eslint.io/rules/no-floating-promises/
      "storybook/await-interactions": "off",
      // Not applicable in our web-component setup
      "storybook/csf-component": "off",
      // This rule is for detecting usages of deprecated feature that we don't use
      "storybook/hierarchy-separator": "off",
      // Not applicable in our web-component setup
      "storybook/no-title-property-in-meta": "off",
      // Not applicable as we have a central Storybook config (@arcgis/storybook-utils)
      "storybook/no-uninstalled-addons": "off",
      // We never used storiesOf, and it's no longer included in Storybook
      "storybook/no-stories-of": "off",
      // Redundant with TypeScript
      "storybook/context-in-play-function": "off"
    }
  }
];

// src/config/lumina.ts
var lumina_default2 = [
  ...storybookConfig,
  {
    ...lumina_default.configs.recommended,
    files: ["**/*.tsx"]
  },
  // Enable this rule in both .ts and .tsx files
  {
    files: ["**/*.ts", "**/*.tsx"],
    plugins: { lumina: lumina_default },
    rules: {
      "lumina/component-placement-rules": "error"
    }
  },
  {
    files: ["**/*.tsx"],
    rules: {
      // It's a good practice for @method() in components to be async even if
      // they don't have await
      "@typescript-eslint/require-await": "off",
      /*
       * This rule emits false warnings when using Controllers due to
       * limitations of TypeScript when it comes to expressing the type of a
       * property that changes during lifecycle (from non-null to eventual null)
       */
      "@typescript-eslint/no-confusing-void-expression": "off",
      "@typescript-eslint/no-restricted-imports": [
        "error",
        {
          patterns: [
            {
              group: ["/lit"],
              importNames: ["LitElement"],
              message: "Import LitElement from `@arcgis/lumina` instead",
              caseSensitive: true
            },
            {
              group: [
                "/lit/decorators.js",
                "/lit/decorators/property.js",
                "/@lit/reactive-element/decorators.js",
                "/@lit/reactive-element/decorators/property.js"
              ],
              importNames: ["property"],
              message: "Import @property() from `@arcgis/lumina` instead",
              caseSensitive: true
            },
            {
              group: [
                "/lit/decorators.js",
                "/lit/decorators/state.js",
                "/@lit/reactive-element/decorators.js",
                "/@lit/reactive-element/decorators/state.js"
              ],
              importNames: ["state"],
              message: "Import @state() from `@arcgis/lumina` instead",
              caseSensitive: true
            },
            {
              group: [
                "/lit/decorators.js",
                "/lit/decorators/custom-element.js",
                "/@lit/reactive-element/decorators.js",
                "/@lit/reactive-element/decorators/custom-element.js",
                // This does not start with "/" so matches ../../runtime and etc
                "runtime"
              ],
              importNames: ["customElement"],
              message: `Do no import customElement - it will be added at build time. Instead, make sure your component file has the following:
declare global {
  interface DeclareElements {
    "arcgis-your-component": ArcgisYourComponent;
  }
}`,
              caseSensitive: true
            },
            {
              group: [
                "/lit/directives/class-map.js",
                "/lit-html/directives/class-map.js",
                "/lit/directives/style-map.js",
                "/lit-html/directives/style-map.js",
                "/lit/directives/keyed.js",
                "/lit-html/directives/keyed.js",
                "/lit/directives/ref.js",
                "/lit-html/directives/ref.js"
              ],
              importNames: ["classMap", "styleMap", "ref", "keyed"],
              message: `You do not need to use classMap(), styleMap(), keyed() or ref() Lit directives - they will be auto-added at build time as necessary.`,
              caseSensitive: true
            },
            {
              group: ["/@lit/context"],
              importNames: ["ContextProvider", "ContextConsumer", "provide", "consume"],
              message: `For lazy-loading compatibility, import the useContextProvider() and the useContextConsumer() controllers from @arcgis/lumina rather than directly calling the Lit's controllers/decorators.`,
              caseSensitive: true
            }
          ]
        }
      ]
    }
  }
  /*{
    ...eslintPluginLit.configs["flat/recommended"],
    files: ["**\/*.tsx"],
    rules: {
      // While some rules provided by the eslint-plugin-lit are helpful, most of
      // them only apply to html`` tagged template literals - since we are using
      // JSX, those rules don't work out of the box (or are not even needed
      // because TypeScript would report the issues those rules try to catch).
      //
      // The only vaguely useful is lit/no-this-assign-in-render, however, we have
      // TypeScript config that forces us to add "override" to any property
      // that shadows prototype - that should catch accidental usages.
      // Otherwise, having a `@property() override title=""` is a good way to
      // document that your component reads this native property, and to get
      // notified when it changes.
      //
      // Thus, as of 1.15.0, none of the rules in that plugin are useful for us.
    },
  },*/
  /*{
    ...eslintPluginWc.configs["flat/recommended"],
    settings: {
      wc: {
        elementBaseClasses: ["LitElement"],
      },
    },
    // For all tsx files
    files: ["**\/*.tsx"],
    // eslint-plugin-wc was written for no-TypeScript codebases that don't use
    // any frameworks. None of it's rules as of v2.2.0 apply or are really
    // useful to us.
    //
    // What follows is explanation of why the following rules are off:
    rules: {
      // This rule wrongly gets triggered for all classes, not just web
      // components
      "wc/no-constructor-params": "off",
      // We are not defining custom elements using customElement.define()
      "wc/no-invalid-element-name": "off",
      // All shadow roots should be created by LitElement
      "wc/attach-shadow-constructor": "off",
      // Since we have lazy loading, all imperative dom interactions will go
      // through this.el.*, which this rule doesn't detect
      "wc/no-self-class": "off",
      // Since we have lazy loading, all imperative dom interactions will go
      // through this.el.*, which this rule doesn't detect
      "wc/no-constructor-attributes": "off",
      // Not needed with TypeScript and Lit
      "wc/guard-super-call": "off",
      // Implementing attributeChangedCallback is not needed with Lit
      "wc/no-child-traversal-in-attributechangedcallback": "off",
      // This rule might be ok, but it will never report anything for us since
      // our DOM interactions go though this.el.*, rather than this.*
      "wc/no-child-traversal-in-connectedcallback": "off",
      // All shadow roots should be created by LitElement
      "wc/no-closed-shadow-root": "off",
      // We don't use customElement.define so this rule will never report
      "wc/no-invalid-extends": "off",
      // Good rule, but most of the time listeners will be setup using
      // this.listen(), so this rule is useless. When addEventListener is
      // used, it might be inside this.manager.onLifecycle(), followed by
      // removeEventListener - this rule won't detect such usages and will
      // falsely report
      "wc/require-listener-teardown": "off",
      // Lumina allows defining multiple components in a file
      "wc/file-name-matches-element": "off",
      // Off because
      // - we have TypeScript that will force us to add "override" to any
      //   property that shadows prototype, thus this rule becomes somewhat
      //   redundant
      // - the rule is too broad - names like "onClicked" should be allowed
      "wc/no-method-prefixed-with-on": "off",
      // `@arcgis/lumina-compiler` includes a better check for this
      "wc/tag-name-matches-class": "off",
    },
  },*/
];
export {
  lumina_default2 as default
};
