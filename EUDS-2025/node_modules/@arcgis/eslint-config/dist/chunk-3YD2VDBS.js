import {
  makeEslintPlugin
} from "./chunk-FVTAJXPI.js";

// src/plugins/lumina/rules/add-missing-jsx-import.ts
import { AST_NODE_TYPES as AST_NODE_TYPES2 } from "@typescript-eslint/utils";

// src/plugins/lumina/utils/creator.ts
import { ESLintUtils } from "@typescript-eslint/utils";
var createRule = ESLintUtils.RuleCreator(
  (rule) => `https://devtopia.esri.com/WebGIS/arcgis-web-components/tree/main/packages/support-packages/eslint-config/src/plugins/lumina/rules/${rule}.ts`
);

// src/plugins/lumina/utils/estree.ts
import { AST_NODE_TYPES } from "@typescript-eslint/utils";
var unwrapExpression = (expression) => expression.type === AST_NODE_TYPES.TSAsExpression || expression.type === AST_NODE_TYPES.TSNonNullExpression || expression.type === AST_NODE_TYPES.TSSatisfiesExpression ? unwrapExpression(expression.expression) : expression;
var luminaEntrypointName = "@arcgis/lumina";
var luminaJsxExportName = "h";
function checkForLuminaJsx() {
  const ImportDeclaration = (node) => {
    if (node.source.value !== luminaEntrypointName) {
      return;
    }
    for (const specifier of node.specifiers) {
      if (specifier.type === AST_NODE_TYPES.ImportSpecifier && (specifier.imported.type === AST_NODE_TYPES.Identifier && specifier.imported.name === luminaJsxExportName || specifier.imported.type === AST_NODE_TYPES.Literal && specifier.imported.value === luminaJsxExportName)) {
        withProperty.isLuminaJsx = true;
        return;
      }
    }
  };
  const withProperty = ImportDeclaration;
  return withProperty;
}
function hasDecorator(node, decoratorName) {
  return node.decorators.some(
    (decorator) => decorator.expression.type === AST_NODE_TYPES.CallExpression && decorator.expression.callee.type === AST_NODE_TYPES.Identifier && decorator.expression.callee.name === decoratorName
  ) ?? false;
}
function extractDeclareElementsInterface(node) {
  return node.kind === "global" ? node.body.body.find(
    (node2) => node2.type === AST_NODE_TYPES.TSInterfaceDeclaration && node2.id.name === "DeclareElements"
  ) : void 0;
}
function isCreateEvent(node) {
  return node.value?.type === AST_NODE_TYPES.CallExpression && node.value.callee.type === AST_NODE_TYPES.Identifier && node.value.callee.name === "createEvent" && !node.static;
}
var getProperty = (properties, name) => properties?.find(
  (option) => option.type === AST_NODE_TYPES.Property && option.key.type === AST_NODE_TYPES.Identifier && option.key.name === name
)?.value;
function isGetterWithoutSetter(node) {
  const isGetter = node.type === AST_NODE_TYPES.MethodDefinition && node.kind === "get";
  if (!isGetter) {
    return false;
  }
  const index = node.parent.body.indexOf(node);
  const previousNode = node.parent.body.at(index - 1);
  const nextNode = node.parent.body.at(index + 1);
  const name = getName(node);
  if (name === void 0) {
    return false;
  }
  const previousIsSetter = previousNode?.type === AST_NODE_TYPES.MethodDefinition && previousNode.kind === "set" && getName(previousNode) === name;
  if (previousIsSetter) {
    return false;
  }
  const nextIsSetter = nextNode?.type === AST_NODE_TYPES.MethodDefinition && nextNode.kind === "set" && getName(nextNode) === name;
  return !nextIsSetter;
}
function getName(node) {
  if (node.key.type === AST_NODE_TYPES.Identifier) {
    return node.key.name;
  } else if (node.key.type === AST_NODE_TYPES.Literal && typeof node.key.value === "string") {
    return node.key.value;
  } else {
    return void 0;
  }
}
function parsePropertyDecorator(decorator) {
  const isPropertyDecorator = decorator.expression.type === AST_NODE_TYPES.CallExpression && decorator.expression.callee.type === AST_NODE_TYPES.Identifier && decorator.expression.callee.name === "property";
  if (!isPropertyDecorator) {
    return;
  }
  const callExpression = decorator?.expression.type === AST_NODE_TYPES.CallExpression ? decorator.expression : void 0;
  if (callExpression === void 0) {
    return;
  }
  const options = callExpression.arguments[0]?.type === AST_NODE_TYPES.ObjectExpression ? callExpression.arguments[0] : void 0;
  const properties = options?.properties;
  return {
    callExpression,
    options,
    properties
  };
}
function isBindThisCallee(callee) {
  return callee.type === AST_NODE_TYPES.MemberExpression && // expression.identifier(this)
  callee.property.type === AST_NODE_TYPES.Identifier && // expression.bind(this)
  callee.property.name === "bind" && // expression.expression.bind(this)
  callee.object.type === AST_NODE_TYPES.MemberExpression && // expression.identifier.bind(this)
  callee.object.property.type === AST_NODE_TYPES.Identifier && // this.identifier.bind(this)
  callee.object.object.type === AST_NODE_TYPES.ThisExpression;
}

// src/plugins/lumina/rules/add-missing-jsx-import.ts
var importDeclaration = `import { ${luminaJsxExportName} } from "${luminaEntrypointName}";`;
var description = `To use Lumina's JSX, you need to ${importDeclaration}`;
var addMissingJsxImport = createRule({
  name: "add-missing-jsx-import",
  meta: {
    docs: {
      description,
      defaultLevel: "error"
    },
    messages: {
      addMissingJsxImport: description
    },
    type: "problem",
    schema: [],
    fixable: "code"
  },
  defaultOptions: [],
  create(context) {
    let errorAlreadyReported = false;
    let isUsingLumina = false;
    let lastImportDeclaration;
    let lastLuminaImportClause;
    let hasLuminaJsxImport = false;
    return {
      ImportDeclaration(node) {
        lastImportDeclaration = node;
        if (node.source.value !== luminaEntrypointName) {
          return;
        }
        isUsingLumina = true;
        const isTypeOnly = node.importKind === "type";
        for (const specifier of node.specifiers) {
          if (!isTypeOnly) {
            lastLuminaImportClause = specifier;
          }
          if (specifier.type === AST_NODE_TYPES2.ImportSpecifier && (specifier.imported.type === AST_NODE_TYPES2.Identifier && specifier.imported.name === luminaJsxExportName || specifier.imported.type === AST_NODE_TYPES2.Literal && specifier.imported.value === luminaJsxExportName)) {
            hasLuminaJsxImport = true;
            return;
          }
        }
      },
      JSXIdentifier(node) {
        if (isUsingLumina && !hasLuminaJsxImport && !errorAlreadyReported) {
          errorAlreadyReported = true;
          context.report({
            messageId: "addMissingJsxImport",
            node,
            fix(fixer) {
              if (lastLuminaImportClause !== void 0) {
                return fixer.insertTextAfter(lastLuminaImportClause, `, ${luminaJsxExportName}`);
              }
              if (lastImportDeclaration !== void 0) {
                return fixer.insertTextAfter(lastImportDeclaration, importDeclaration);
              } else {
                return fixer.insertTextBefore(context.sourceCode.ast, importDeclaration);
              }
            }
          });
        }
      }
    };
  }
});

// src/plugins/lumina/rules/auto-add-type.ts
import { AST_NODE_TYPES as AST_NODE_TYPES3, ESLintUtils as ESLintUtils2 } from "@typescript-eslint/utils";
import ts from "typescript";
var description2 = "Auto add { type: Boolean } or { type: Number } where necessary";
var autoAddType = createRule({
  name: "auto-add-type",
  meta: {
    docs: {
      description: description2,
      defaultLevel: "warn"
    },
    messages: {
      addType: `This property is of {{ type }} type, yet the type is not trivially inferrable from the AST without type-checking. Such properties require a { type: {{ type }} } annotation.

More information: https://devtopia.esri.com/WebGIS/arcgis-web-components/issues/1991`,
      typeAnnotationMismatchesActualType: "The @property({type: {{type}} }) doesn't match the actual property type ({{actualType}}).",
      noEmptyPropertyObject: "Replace @property({}) with @property()",
      noUnnecessaryType: "Property type is trivially inferrable without type-checking - remove needless { type: {{ type }} } annotation.",
      unhandledType: `The default Lit attribute<-->property converter does not define any behavior for @property({ type: {{type}} }). Consider removing this type annotation, or adding a custom converter @property({ converter: ... }) to handle this type`
    },
    type: "problem",
    schema: [],
    fixable: "code"
  },
  defaultOptions: [],
  create(context) {
    const services = ESLintUtils2.getParserServices(context);
    return {
      Decorator(decorator) {
        const part = parsePropertyDecorator(decorator);
        if (part === void 0) {
          return;
        }
        const { options, properties, callExpression } = part;
        const property = decorator.parent;
        if (property?.type !== AST_NODE_TYPES3.MethodDefinition && property?.type !== AST_NODE_TYPES3.PropertyDefinition) {
          return;
        }
        const trivialType = inferTrivialType(property);
        const typeProperty = getProperty(properties, "type");
        const converterProperty = getProperty(properties, "converter");
        const isTrivialType = trivialType === "Number" || trivialType === "Boolean";
        if (isTrivialType && typeProperty !== void 0 && typeProperty.type === AST_NODE_TYPES3.Identifier && (typeProperty.name === "Number" || typeProperty.name === "Boolean")) {
          context.report({
            node: typeProperty,
            messageId: "noUnnecessaryType",
            data: {
              type: typeProperty.name
            },
            fix(fixer) {
              const nextToken = context.sourceCode.getTokenAfter(typeProperty.parent);
              const isTrailingComma = nextToken && nextToken.value === ",";
              return isTrailingComma ? fixer.removeRange([typeProperty.parent.range[0], nextToken.range[1]]) : fixer.remove(typeProperty.parent);
            }
          });
          return;
        }
        if (
          // Do not emit any warnings if has "converter" as we don't know what the converter does
          converterProperty === void 0 && typeProperty?.type === AST_NODE_TYPES3.Identifier && !builtInConverterTypes.has(typeProperty.name)
        ) {
          context.report({
            node: typeProperty,
            messageId: "unhandledType",
            data: {
              type: typeProperty.name
            }
          });
          return;
        }
        if (isTrivialType) {
          return;
        }
        if (options !== void 0 && properties?.length === 0) {
          context.report({
            node: options,
            messageId: "noEmptyPropertyObject",
            fix(fixer) {
              return fixer.replaceText(
                options,
                context.sourceCode.getCommentsInside(options).map((comment) => context.sourceCode.getText(comment)).join("\n")
              );
            }
          });
          return;
        }
        const attributeOption = getProperty(properties, "attribute");
        const isAttributeFalse = attributeOption?.type === AST_NODE_TYPES3.Literal && attributeOption.value === false;
        if (isAttributeFalse) {
          return;
        }
        const type = services.getTypeAtLocation(property);
        const typeFlags = (type.flags & ts.TypeFlags.Union ? type.types : [type]).reduce(
          (flags, type2) => flags | type2.flags,
          0
        );
        const isTypeCastable = (typeFlags & (ts.TypeFlags.String | ts.TypeFlags.Any | ts.TypeFlags.Unknown)) === 0;
        const isNumberType = isTypeCastable && typeFlags & ts.TypeFlags.NumberLike;
        const isBooleanType = isTypeCastable && typeFlags & ts.TypeFlags.BooleanLike;
        if (isNumberType && isBooleanType) {
          return;
        }
        if (!isNumberType && !isBooleanType) {
          return;
        }
        if (typeProperty !== void 0) {
          if (
            // Do not emit any warnings if has "converter" as we don't know what the converter does
            converterProperty === void 0 && typeProperty.type === AST_NODE_TYPES3.Identifier && (typeProperty.name === "Number" && isBooleanType || typeProperty.name === "Boolean" && isNumberType)
          ) {
            context.report({
              node: typeProperty,
              messageId: "typeAnnotationMismatchesActualType",
              data: {
                type: typeProperty.name,
                actualType: isNumberType ? "Number" : "Boolean"
              }
            });
          }
          return;
        }
        const comments = context.sourceCode.getCommentsBefore(property);
        const isDocsOnlyReadOnly = comments.some((comment) => comment.value.includes("@readonly"));
        const readOnlyProperty = getProperty(properties, "readOnly");
        const hasReadOnlyFlag = readOnlyProperty?.type === AST_NODE_TYPES3.Literal && readOnlyProperty.value === true;
        const isReadOnly = isDocsOnlyReadOnly || hasReadOnlyFlag || isGetterWithoutSetter(property);
        const reflectsProperty = getProperty(properties, "reflects");
        if (isReadOnly && (!isBooleanType || reflectsProperty?.type !== AST_NODE_TYPES3.Literal || reflectsProperty.value !== true)) {
          return;
        }
        context.report({
          messageId: "addType",
          data: {
            type: isNumberType ? "Number" : "Boolean"
          },
          node: property,
          fix(fixer) {
            const sourceCode = context.sourceCode;
            if (options === void 0) {
              const token = sourceCode.getTokenAfter(callExpression.callee, {
                filter: (token2) => token2.value === "("
              });
              return fixer.insertTextAfterRange(token.range, `{ type: ${isNumberType ? "Number" : "Boolean"} }`);
            } else {
              return fixer.insertTextBefore(options.properties[0], `type: ${isNumberType ? "Number" : "Boolean"}, `);
            }
          }
        });
      }
    };
  }
});
function inferTrivialType(member) {
  const type = member.type === AST_NODE_TYPES3.PropertyDefinition ? member.typeAnnotation?.typeAnnotation : member.type === AST_NODE_TYPES3.MethodDefinition && member.kind === "set" ? member.value.params[0]?.typeAnnotation?.typeAnnotation : member.type === AST_NODE_TYPES3.MethodDefinition && member.kind === "get" ? member.value.returnType?.typeAnnotation : void 0;
  if (type === void 0) {
    if (member.value?.type === AST_NODE_TYPES3.Literal && typeof member.value.value === "number" || member.value?.type === AST_NODE_TYPES3.UnaryExpression && member.value.argument.type === AST_NODE_TYPES3.Literal && typeof member.value.argument.value === "number" && member.value.operator === "-") {
      return "Number";
    }
    if (member.value?.type === AST_NODE_TYPES3.Literal && typeof member.value.value === "boolean") {
      return "Boolean";
    }
  } else if (type.type === AST_NODE_TYPES3.TSNumberKeyword) {
    return "Number";
  } else if (type.type === AST_NODE_TYPES3.TSBooleanKeyword) {
    return "Boolean";
  }
  return "Other";
}
var builtInConverterTypes = /* @__PURE__ */ new Set(["Number", "Boolean", "Array", "Object"]);

// ../components-build-utils/dist/index.js
import { sep as sep2 } from "path";
import posix from "path/posix";
import win32 from "path/win32";
var isPosix = sep2 === posix.sep;
var toPosixPathSeparators = (relativePath) => relativePath.includes(win32.sep) ? relativePath.replaceAll(win32.sep, posix.sep) : relativePath;
var getCwd = isPosix ? process.cwd : () => toPosixPathSeparators(process.cwd());
var path = isPosix ? posix : {
  ...win32,
  sep: posix.sep,
  join(...paths) {
    const result = win32.join(...paths);
    return toPosixPathSeparators(result);
  },
  normalize(path2) {
    const result = win32.normalize(path2);
    return toPosixPathSeparators(result);
  },
  relative(from, to) {
    const result = win32.relative(from, to);
    return toPosixPathSeparators(result);
  },
  dirname(path2) {
    const result = win32.dirname(path2);
    return toPosixPathSeparators(result);
  },
  resolve(...paths) {
    const result = win32.resolve(...paths);
    return toPosixPathSeparators(result);
  },
  toNamespacedPath(path2) {
    const result = win32.toNamespacedPath(path2);
    return toPosixPathSeparators(result);
  }
};

// src/plugins/lumina/rules/component-placement-rules.ts
var description3 = `Lumina component must be declared in a TSX file with a matching folder name located inside of src/components folder.`;
var componentPlacementRules = createRule({
  name: "component-placement-rules",
  meta: {
    docs: {
      description: description3,
      defaultLevel: "error"
    },
    messages: {
      fileFolderNameMismatch: "Lumina component must be declared in a file whose name (without extension) matches the parent folder name.\n\nCreating components in nested folders is supported as long as the file name matches the immediate parent folder name.",
      extensionNotTsx: "Lumina component must be declared in a .tsx file.",
      noComponentOutsideSrcComponents: "All lumina components must be declared within the src/components folder. Inside that folder, you can create sub-folders for structuring component files."
    },
    type: "problem",
    schema: [],
    fixable: "code"
  },
  defaultOptions: [],
  create(context) {
    return {
      TSModuleDeclaration(node) {
        const luminaDeclarationInterface = extractDeclareElementsInterface(node);
        if (luminaDeclarationInterface === void 0) {
          return;
        }
        const filePath = toPosixPathSeparators(context.filename);
        const containsSrcComponents = filePath.includes("/src/components/");
        if (!containsSrcComponents) {
          context.report({ messageId: "noComponentOutsideSrcComponents", node: luminaDeclarationInterface });
        }
        const isFileExtensionTsx = filePath.endsWith(".tsx");
        if (!isFileExtensionTsx) {
          context.report({ messageId: "extensionNotTsx", node: luminaDeclarationInterface });
          return;
        }
        const [fileName, folderName] = filePath.split("/").reverse();
        const extensionlessFileName = fileName.slice(0, -".tsx".length);
        if (folderName !== extensionlessFileName) {
          context.report({ messageId: "fileFolderNameMismatch", node: luminaDeclarationInterface });
        }
      }
    };
  }
});

// src/plugins/lumina/rules/consistent-event-naming.ts
import { AST_NODE_TYPES as AST_NODE_TYPES4 } from "@typescript-eslint/utils";
var description4 = `Enforce consistent event naming.`;
var defaultOptions = [
  {
    eventNamespaces: ["arcgis"],
    includeComponentNameInEventName: false
  }
];
var consistentEventNaming = createRule({
  name: "consistent-event-naming",
  meta: {
    docs: {
      description: description4,
      defaultLevel: "warn"
    },
    messages: {
      eventNamespaceError: `Custom event name must start with one of the following prefixes: {{ prefixes }}.

Details: https://qawebgis.esri.com/components/lumina/events#best-practices-around-emitting-events`,
      componentNameInEventError: `For consistency, event name should not start with component name.

Discussion: https://devtopia.esri.com/WebGIS/arcgis-web-components/discussions/307`,
      noComponentNameInEventError: `For consistency, event name should include component name.`,
      missingPrivateJsDocTag: `Internal and private events must be marked with @internal or @private JSDoc tag.`
    },
    type: "problem",
    schema: [
      {
        type: "object",
        properties: {
          eventNamespaces: {
            type: "array",
            items: {
              type: "string"
            }
          },
          includeComponentNameInEventName: {
            type: "boolean"
          }
        },
        additionalProperties: false
      }
    ]
  },
  defaultOptions,
  create(context, options) {
    const eventNamespaces = options[0].eventNamespaces;
    const includeComponentNameInEventName = options[0].includeComponentNameInEventName;
    return {
      PropertyDefinition(node) {
        const isLuminaEvent = isCreateEvent(node);
        if (!isLuminaEvent) {
          return;
        }
        const comments = context.sourceCode.getCommentsBefore(node);
        const isDeprecated = comments.some((comment) => comment.value.includes("@deprecated"));
        if (isDeprecated) {
          return;
        }
        const componentName = context.sourceCode.getAncestors(node).find((ancestor) => ancestor.type === AST_NODE_TYPES4.ClassDeclaration)?.id?.name;
        if (componentName === void 0) {
          return;
        }
        const propertyName = node.key.type === AST_NODE_TYPES4.Identifier ? node.key.name : node.key.type === AST_NODE_TYPES4.Literal ? node.key.value : void 0;
        if (typeof propertyName !== "string") {
          return;
        }
        let eventName = propertyName;
        if (eventNamespaces.length > 0) {
          const currentNamespace = eventNamespaces.find((namespace) => eventName.startsWith(namespace));
          if (currentNamespace === void 0) {
            context.report({
              messageId: "eventNamespaceError",
              data: {
                prefixes: eventNamespaces.join(", ")
              },
              node: node.key
            });
            return;
          }
          eventName = eventName.slice(currentNamespace.length);
        }
        const startsWithInternal = eventName.toLowerCase().startsWith("internal");
        if (startsWithInternal || eventName.toLowerCase().startsWith("private")) {
          const hasInternalJsDocTag = comments.some((comment) => comment.value.includes("@internal"));
          const hasPrivateJsDocTag = comments.some((comment) => comment.value.includes("@private"));
          if (!hasInternalJsDocTag && !hasPrivateJsDocTag) {
            context.report({
              messageId: "missingPrivateJsDocTag",
              node: node.key
            });
          }
          eventName = startsWithInternal ? eventName.slice("internal".length) : eventName.slice("private".length);
        }
        const capitalIndex = capitalAfterLower.exec(componentName)?.index;
        const unNamespacedComponentName = capitalIndex === void 0 ? void 0 : componentName.slice(capitalIndex) || void 0;
        const includesComponentName = eventName.startsWith(componentName) || unNamespacedComponentName !== void 0 && eventName.startsWith(unNamespacedComponentName);
        if (includeComponentNameInEventName && !includesComponentName) {
          context.report({
            messageId: "noComponentNameInEventError",
            node: node.key
          });
        } else if (!includeComponentNameInEventName && includesComponentName) {
          context.report({
            messageId: "componentNameInEventError",
            node: node.key
          });
        }
      }
    };
  }
});
var capitalAfterLower = /(?<=[a-z\d])[A-Z]/u;

// src/plugins/lumina/rules/decorators-context.ts
var description5 = `Enforce that @property(), @method() and createEvent() members are used in the correct context.`;
var decoratorsContext = createRule({
  name: "decorators-context",
  meta: {
    docs: {
      description: description5,
      defaultLevel: "error"
    },
    messages: {
      publicApiMustBePublic: `@property(), @method() and createEvent() members must not have private or protected modifier.
      
If you wish to hide this member from public documentation, use @private or @protected JSDoc tags instead. Documentation: https://qawebgis.esri.com/components/lumina/documenting-components#excluding-api-from-public-documentation`,
      noPropertyDecoratorOnMethods: `Methods must not have @property() nor @state() decorator. Did you mean @property() instead?`,
      noCombinedPropertyEvent: `Property may either be an event (initialized with createEvent()) or a property (has @property() decorator), but not both`,
      noCombinedPropertyState: `Property may either be a state (initialized with @state()) or a property (has @property() decorator), but not both`,
      noComputedName: `Computed property names are not allowed as they are not statically analyzable`
    },
    type: "problem",
    schema: [],
    fixable: "code"
  },
  defaultOptions: [],
  create(context) {
    return {
      PropertyDefinition(node) {
        const hasPropertyDecorator = hasDecorator(node, "property");
        const isPrivateOrProtected = node.accessibility === "private" || node.accessibility === "protected";
        if (hasPropertyDecorator && isPrivateOrProtected) {
          context.report({ messageId: "publicApiMustBePublic", node });
        }
        const isLuminaEvent = isCreateEvent(node);
        if (isLuminaEvent && isPrivateOrProtected) {
          context.report({ messageId: "publicApiMustBePublic", node });
        }
        if (isLuminaEvent && hasPropertyDecorator) {
          context.report({ messageId: "noCombinedPropertyEvent", node });
        }
        const hasStateDecorator = hasDecorator(node, "state");
        if (hasStateDecorator && hasPropertyDecorator) {
          context.report({ messageId: "noCombinedPropertyState", node });
        }
        if (hasPropertyDecorator && node.computed) {
          context.report({ messageId: "noComputedName", node });
        }
      },
      MethodDefinition(node) {
        const hasMethodDecorator = hasDecorator(node, "method");
        const hasPropertyDecorator = hasDecorator(node, "property");
        const hasStateDecorator = hasDecorator(node, "state");
        const isPrivateOrProtected = node.accessibility === "private" || node.accessibility === "protected";
        if (hasMethodDecorator && isPrivateOrProtected) {
          context.report({ messageId: "publicApiMustBePublic", node });
        }
        if (hasMethodDecorator && (hasPropertyDecorator || hasStateDecorator)) {
          context.report({ messageId: "noPropertyDecoratorOnMethods", node });
        }
        if (hasStateDecorator && hasPropertyDecorator) {
          context.report({ messageId: "noCombinedPropertyState", node });
        }
        const isRealMethod = node.kind === "method";
        if (isRealMethod && (hasPropertyDecorator || hasStateDecorator)) {
          context.report({ messageId: "noPropertyDecoratorOnMethods", node });
        }
        if ((hasPropertyDecorator || hasMethodDecorator) && node.computed) {
          context.report({ messageId: "noComputedName", node });
        }
      }
    };
  }
});

// src/plugins/lumina/rules/member-ordering.ts
import { AST_NODE_TYPES as AST_NODE_TYPES7 } from "@typescript-eslint/utils";

// src/plugins/lumina/rules/member-ordering/config.ts
import { AST_NODE_TYPES as AST_NODE_TYPES5 } from "@typescript-eslint/utils";
var ordering = [
  /*
   * Putting static before instance members is a common OOP convention.
   * Static members are always evaluated before instance members.
   */
  "Static Members",
  /**
   * Put private properties before public, because private properties are
   * often used as a default value for public properties.
   */
  "Private Properties",
  /**
   * Put private properties before public, because private properties are often
   * used as a default value for public properties.
   */
  "State Properties",
  /*
   * Properties are the key component API. Also, since default values of
   * properties evaluate before the constructor, they should logically be before
   * the constructor.
   */
  "Public Properties",
  /*
   * Methods should be a supplementary component API, not primary, so are listed
   * after properties. At the same time, it is nice to keep public component API
   * all in one place.
   */
  "Public Methods",
  /*
   * Put events near properties and methods to keep all public component API in
   * one place.
   */
  "Events",
  /*
   * Lifecycle methods like constructor and connectedCallback are executed
   * after all properties have default values, but before any render functions.
   */
  "Lifecycle",
  /*
   * Private methods in between lifecycles and rendering as they are often
   * called by either of them.
   */
  "Private Methods",
  /*
   * Fred:
   * The reason rendering methods are at the bottom of my modules because I can
   * quickly jump to the bottom find the rendering method and work on it. Less
   * scrolling.
   * Once a module has been implemented, most of the bugs/enhancements occur in
   * the rendering methods.
   */
  "Rendering"
];
var getWireframe = () => new Map(ordering.map((region) => [region, []]));
var entries = Object.entries;
var regionMatchers = entries({
  "Static Members": (node) => node.type === AST_NODE_TYPES5.StaticBlock || "static" in node && node.static,
  "Lifecycle": (_node, name) => lifecyclesSet.has(name),
  "Public Methods": (node) => "decorators" in node && hasDecorator(node, "method"),
  "Public Properties": (node) => "decorators" in node && hasDecorator(node, "property"),
  "State Properties": (node) => "decorators" in node && hasDecorator(node, "state"),
  "Events": isEvent,
  "Rendering": (_node, name) => name.startsWith("render") || name.startsWith("_render"),
  "Private Properties": (node) => (
    // We don't yet support public accessor properties
    node.type === AST_NODE_TYPES5.PropertyDefinition || node.type === AST_NODE_TYPES5.AccessorProperty
  ),
  "Private Methods": () => true
});
var definitelyComponentRegions = /* @__PURE__ */ new Set([
  "Rendering",
  "State Properties",
  "Public Methods",
  "Events"
]);
var regionsArray = regionMatchers.map(([key]) => key);
function isEvent(node, name) {
  if (node.type !== AST_NODE_TYPES5.PropertyDefinition) {
    return false;
  }
  if (name === "arcgisPropertyChange") {
    return true;
  }
  const initializer = node.value;
  if (initializer?.type !== AST_NODE_TYPES5.CallExpression) {
    return false;
  }
  const callExpression = initializer.callee;
  const functionName = callExpression.type === AST_NODE_TYPES5.Identifier ? callExpression.name : callExpression.type === AST_NODE_TYPES5.CallExpression && callExpression.callee.type === AST_NODE_TYPES5.Identifier ? callExpression.callee.name : void 0;
  return functionName === "createEvent" || functionName === "reEmitEvent" || functionName === "usePropertyChange";
}
var lifecycles = [
  "constructor",
  "connectedCallback",
  "load",
  "shouldUpdate",
  // Not an actual lifecycle method, but can be temporary inserted by the codemod
  "_shouldUpdate",
  "willUpdate",
  "update",
  "firstUpdated",
  "updated",
  "loaded",
  "disconnectedCallback"
];
var lifecyclesSet = new Set(lifecycles);
var supportedNodeTypes = {
  MethodDefinition: true,
  PropertyDefinition: true,
  AccessorProperty: true,
  StaticBlock: true,
  // These should not be present in non-abstract Lumina component classes
  TSAbstractAccessorProperty: false,
  TSAbstractMethodDefinition: false,
  TSAbstractPropertyDefinition: false,
  TSIndexSignature: false
};

// src/plugins/lumina/rules/member-ordering/comments.ts
import { AST_TOKEN_TYPES } from "@typescript-eslint/utils";
function categorizeComments(membersData, sourceCode) {
  const categorized = {
    header: [],
    regionFooter: /* @__PURE__ */ new Map(),
    memberLineEnd: /* @__PURE__ */ new Map(),
    footer: [],
    membersByName: /* @__PURE__ */ new Map()
  };
  let regionName;
  membersData.forEach((memberData, index) => {
    const nameNodes = categorized.membersByName.get(memberData.name);
    if (nameNodes !== void 0) {
      nameNodes.push(memberData);
    } else {
      categorized.membersByName.set(memberData.name, [memberData]);
    }
    memberData.comments = handleLineEndComment(memberData.comments, membersData.at(index - 1), categorized);
    let newRegionName;
    const lastRegionStart = memberData.comments.findLastIndex((comment) => {
      const match = parseRegionComment(comment);
      const isRegionStart = match !== void 0 && match.end === void 0;
      newRegionName = match?.name;
      return isRegionStart;
    });
    if (lastRegionStart !== -1) {
      const commentsBeforeNewRegionStart = memberData.comments.slice(0, lastRegionStart);
      const previousMember = membersData.at(index - 1);
      handleCommentsAroundEndRegion(
        commentsBeforeNewRegionStart,
        false,
        previousMember ?? memberData,
        categorized,
        regionName
      );
      memberData.comments = memberData.comments.slice(lastRegionStart + 1);
      regionName = newRegionName;
    }
    const isLastNode = index === membersData.length - 1;
    if (isLastNode) {
      const trailingComments = sourceCode.getCommentsAfter(memberData.member);
      const remainingTrailingComments = handleLineEndComment(trailingComments, memberData, categorized);
      const previousMember = membersData.at(index - 1);
      handleCommentsAroundEndRegion(
        remainingTrailingComments,
        true,
        previousMember ?? memberData,
        categorized,
        regionName
      );
    }
  });
  return categorized;
}
function handleLineEndComment(comments, previousNode, categorized) {
  if (comments.at(0)?.loc.start.line === previousNode?.member.loc.end.line) {
    categorized.memberLineEnd.set(previousNode, comments.slice(0, 1));
    return comments.slice(1);
  }
  return comments;
}
function handleCommentsAroundEndRegion(commentsBeforeNewRegionStart, isFooter, lastMember, categorized, regionName) {
  if (regionName === void 0) {
    const destination = isFooter ? categorized.footer : categorized.header;
    destination.push(...commentsBeforeNewRegionStart);
  } else {
    const firstEndRegion = commentsBeforeNewRegionStart.findIndex(
      (comment) => parseRegionComment(comment)?.end !== void 0
    );
    let previousRegionComments = commentsBeforeNewRegionStart;
    if (firstEndRegion !== -1) {
      categorized.footer.push(...commentsBeforeNewRegionStart.slice(firstEndRegion + 1));
      previousRegionComments = commentsBeforeNewRegionStart.slice(0, firstEndRegion);
    }
    const existingFooter = categorized.regionFooter.get(regionName);
    if (existingFooter === void 0) {
      categorized.regionFooter.set(regionName, { comments: Array.from(previousRegionComments), lastMember });
    } else {
      existingFooter.comments.push(...previousRegionComments);
    }
  }
}
var normalizeComments = (comments = [], sourceCode, indent = "  ") => comments.filter((comment) => parseRegionComment(comment) === void 0).map((comment) => `${indent}${sourceCode.getText(comment)}`).join("\n").replaceAll(reJsApiSectionComment, "");
var join = (left, right, joiner = "\n\n") => left === "" || right === "" ? right || left : `${left}${joiner}${right}`;
var reRegionComment = /^ ?#(?<end>end)?region ?(?<name>[^\n]*)$/u;
var parseRegionComment = (comment) => comment.type === AST_TOKEN_TYPES.Line ? reRegionComment.exec(comment.value)?.groups : void 0;
var reJsApiSectionComment = /^  \/\/ ?-{4,}\n(?:  \/\/\s*\n)?  \/\/\s+[^\s][^\n]+\n(?:  \/\/\s*\n)?  \/\/ ?-{4,}/gmu;

// src/plugins/lumina/rules/member-ordering/normalize.ts
import { AST_NODE_TYPES as AST_NODE_TYPES6 } from "@typescript-eslint/utils";
function getNormalizedRegions(membersByName) {
  const regions = getWireframe();
  membersByName.values().forEach((members) => {
    const lowestRegionIndex = members.reduce(
      (min, { region }) => Math.min(min, regionsArray.indexOf(region)),
      Number.POSITIVE_INFINITY
    );
    if (members.length === 2 && members[0].member.type === AST_NODE_TYPES6.MethodDefinition && members[0].member.kind === "set") {
      members.reverse();
    }
    const regionName = regionsArray[lowestRegionIndex];
    regions.get(regionName).push(...members);
  });
  const normalizedRegions = Array.from(regions).filter(([_region, members]) => members.length > 0).map(
    ([region, members]) => [region, sortableRegions.has(region) ? members.sort(sortFunction.bind(void 0, region)) : members]
  );
  return normalizedRegions;
}
var sortableRegions = /* @__PURE__ */ new Set(["Public Methods", "Events", "Lifecycle"]);
function sortFunction(region, leftMember, rightMember) {
  let leftName = leftMember.name;
  let rightName = rightMember.name;
  if (region === "Lifecycle") {
    const compare = lifecycles.indexOf(leftName) - lifecycles.indexOf(rightName);
    return compare < 0 ? -1 : 1;
  }
  if (leftName.startsWith("_")) {
    leftName = leftName.slice(1);
  }
  if (rightName.startsWith("_")) {
    rightName = rightName.slice(1);
  }
  if (leftName < rightName) {
    return -1;
  } else if (leftName > rightName) {
    return 1;
  } else {
    return 0;
  }
}
function reParentOrphanFooterComments(normalizedRegions, regionFooter) {
  const finalRegions = new Set(normalizedRegions.map(([region]) => region));
  regionFooter.forEach(({ comments, lastMember }, originalRegionName) => {
    const regionStillExists = finalRegions.has(originalRegionName);
    if (regionStillExists) {
      return;
    }
    const newFooterCommentsParent = lastMember.region;
    const existingParentFooter = regionFooter.get(newFooterCommentsParent);
    if (existingParentFooter === void 0) {
      regionFooter.set(newFooterCommentsParent, { comments, lastMember });
    } else {
      existingParentFooter.comments.push(...comments);
    }
  });
}

// src/plugins/lumina/rules/member-ordering/build.ts
function buildNewBody(normalizedRegions, strayComments, sourceCode) {
  const newRegions = normalizedRegions.map(([region, members]) => {
    const memberLines = members.map((memberData, index) => {
      const { member, comments, name } = memberData;
      const commentsString = normalizeComments(comments, sourceCode);
      const code = sourceCode.getText(member);
      const lineEndComment = normalizeComments(strayComments.memberLineEnd.get(memberData), sourceCode, " ");
      const memberString = `  ${code}${lineEndComment}`;
      const fullMemberString = join(commentsString, memberString, "\n");
      const nextMember = members.at(index + 1);
      const isLast = nextMember === void 0;
      const isNextSameName = name.length > 0 && name === nextMember?.name;
      const separator = isLast ? "" : isNextSameName ? "\n" : "\n\n";
      return `${fullMemberString}${separator}`;
    });
    const footerComments = normalizeComments(strayComments.regionFooter.get(region)?.comments, sourceCode);
    const footer2 = join(footerComments, "  //#endregion", "\n\n");
    return [`  //#region ${region}`, memberLines.join(""), footer2].join("\n\n");
  });
  const header = normalizeComments(strayComments.header, sourceCode);
  const footer = normalizeComments(strayComments.footer, sourceCode);
  const newBodyContent = join(join(header, newRegions.join("\n\n")), footer);
  const newBody = `{
${newBodyContent}
}`;
  return newBody;
}

// src/plugins/lumina/rules/member-ordering.ts
var baseDescription = `Consistently sort component members`;
var memberOrdering = createRule({
  name: "member-ordering",
  meta: {
    docs: {
      description: baseDescription,
      defaultLevel: "warn"
    },
    messages: {
      memberOrdering: "Component member ordering is not consistent. Run ESLint autofix to sort members.",
      unsupportedElementType: "Unsupported class element type: {{ type }}"
    },
    type: "layout",
    schema: [],
    fixable: "whitespace"
  },
  defaultOptions: [],
  create: (context) => ({
    ClassDeclaration(component) {
      const isNamedExport = component.parent?.type === AST_NODE_TYPES7.ExportNamedDeclaration;
      if (!isNamedExport || component.abstract) {
        return;
      }
      const hasExtends = component.superClass !== null;
      if (!hasExtends) {
        return;
      }
      const sourceCode = context.sourceCode;
      const seenNames = /* @__PURE__ */ new Set();
      let currentRegion = "";
      let hasWrongOrdering = false;
      let isDefinitelyComponent = false;
      let hadError = false;
      const membersData = component.body.body.map((member) => {
        const isSupportedType = supportedNodeTypes[member.type];
        if (!isSupportedType) {
          hadError = true;
          context.report({ node: member, messageId: "unsupportedElementType", data: { type: member.type } });
        }
        const name = "key" in member ? getName(member) ?? "" : "";
        const newRegion = regionMatchers.find(([, rules]) => rules(member, name))[0];
        const comments = sourceCode.getCommentsBefore(member);
        if (!hasWrongOrdering) {
          let wrongOrdering = false;
          const previousRegion = currentRegion;
          for (const comment of comments) {
            const region = parseRegionComment(comment);
            if (region === void 0 || region.end !== void 0) {
              continue;
            }
            currentRegion = region.name;
            wrongOrdering ||= currentRegion !== newRegion;
          }
          if (
            /*
             * The @property()/@method() decorator might be missing from this
             * node in case of getter/setter or method overload, while still
             * being in correct ordering.
             * The logic in rule body is lightweight compared to more
             * comprehensive in the autofix to keep common case fast, so we
             * ignore possible errors in getter/setters (but those errors would
             * still be fixed as long as there is any other error in the file).
             */
            !seenNames.has(name) && (member.type !== AST_NODE_TYPES7.MethodDefinition || member.kind !== "get" && member.kind !== "set")
          ) {
            wrongOrdering ||= currentRegion !== newRegion;
            wrongOrdering ||= previousRegion !== currentRegion && ordering.indexOf(previousRegion) > ordering.indexOf(currentRegion);
            hasWrongOrdering = wrongOrdering;
          }
          seenNames.add(name);
        }
        isDefinitelyComponent ||= definitelyComponentRegions.has(newRegion);
        return { member, name, comments, region: newRegion };
      });
      if (!isDefinitelyComponent) {
        return;
      }
      if (hadError) {
        return;
      }
      if (!hasWrongOrdering) {
        return;
      }
      context.report({
        /**
         * Since this rule is autofixable and stylistic, to be less obtrusive,
         * report the error for a single character only, rather than entire
         * component
         */
        loc: {
          start: component.loc.end,
          end: component.loc.end
        },
        messageId: "memberOrdering",
        /*
         * We delay as much work as possible till the autofixer is run because
         * most of the time the rule will be run without need for autofixing.
         */
        fix(fixer) {
          const { membersByName, ...strayComments } = categorizeComments(membersData, sourceCode);
          const normalizedRegions = getNormalizedRegions(membersByName);
          reParentOrphanFooterComments(normalizedRegions, strayComments.regionFooter);
          const newBody = buildNewBody(normalizedRegions, strayComments, sourceCode);
          return fixer.replaceText(component.body, newBody);
        }
      });
    }
  })
});

// src/plugins/lumina/rules/no-ignore-jsdoc-tag.ts
var description6 = `Use @internal or @private JSDoc tag over @ignore. See https://qawebgis.esri.com/components/lumina/documenting-components#excluding-api-from-public-documentation`;
var noIgnoreJsDocTag = createRule({
  name: "no-ignore-jsdoc-tag",
  meta: {
    docs: {
      description: description6,
      defaultLevel: "error"
    },
    messages: {
      noIgnoreJsDocTag: description6
    },
    type: "problem",
    schema: []
  },
  defaultOptions: [],
  create(context) {
    const luminaJsxCheck = checkForLuminaJsx();
    return {
      "ImportDeclaration": luminaJsxCheck,
      "Program:exit"() {
        if (!luminaJsxCheck.isLuminaJsx) {
          return;
        }
        Array.from(
          context.sourceCode.text.matchAll(reIgnore),
          (match) => context.report({
            messageId: "noIgnoreJsDocTag",
            loc: {
              start: context.sourceCode.getLocFromIndex(match.index + "* ".length),
              end: context.sourceCode.getLocFromIndex(match.index + match[0].length)
            }
          })
        );
      }
    };
  }
});
var reIgnore = /\* @ignore/gu;

// src/plugins/lumina/rules/no-incorrect-dynamic-tag-name.ts
import { AST_NODE_TYPES as AST_NODE_TYPES8, ESLintUtils as ESLintUtils3 } from "@typescript-eslint/utils";
import ts2 from "typescript";
var description7 = `Detect incorrect usage of dynamic JSX tag name`;
var noIncorrectDynamicTagName = createRule({
  name: "no-incorrect-dynamic-tag-name",
  meta: {
    docs: {
      description: description7,
      defaultLevel: "error"
    },
    messages: {
      incorrectDynamicTagName: `This is using incorrect dynamic tag name syntax. See documentation on how to use dynamic tag in Lumina's JSX: https://qawebgis.esri.com/components/lumina/jsx#dynamic-tag-name`
    },
    type: "problem",
    schema: []
  },
  defaultOptions: [],
  create(context) {
    const services = ESLintUtils3.getParserServices(context);
    const luminaJsxCheck = checkForLuminaJsx();
    return {
      ImportDeclaration: luminaJsxCheck,
      JSXIdentifier(node) {
        if (!luminaJsxCheck.isLuminaJsx) {
          return;
        }
        const isInTagName = node.parent?.type !== AST_NODE_TYPES8.JSXAttribute;
        if (!isInTagName) {
          return;
        }
        const isCapitalized = !node.name.startsWith(node.name.charAt(0).toLowerCase());
        if (!isCapitalized) {
          return;
        }
        const isCorrectDynamicTagName = node.name === "DynamicHtmlTag" || node.name === "DynamicSvgTag";
        if (isCorrectDynamicTagName) {
          return;
        }
        const type = services.getTypeAtLocation(node);
        const isStringType = type.flags & ts2.TypeFlags.StringLike;
        if (isStringType) {
          context.report({
            messageId: "incorrectDynamicTagName",
            node
          });
        }
      }
    };
  }
});

// src/plugins/lumina/rules/no-inline-arrow-in-ref.ts
import { AST_NODE_TYPES as AST_NODE_TYPES9 } from "@typescript-eslint/utils";
var baseDescription2 = `Do not pass an inline arrow function to a ref prop - such syntax creates a new function on each render, which makes Lit call ref callback again on each render.`;
var description8 = `${baseDescription2}

Alternatives: https://qawebgis.esri.com/components/lumina/jsx#refs`;
var noInlineArrowInRef = createRule({
  name: "no-inline-arrow-in-ref",
  meta: {
    docs: {
      description: baseDescription2,
      defaultLevel: "error"
    },
    messages: {
      errorInlineArrow: description8
    },
    type: "problem",
    schema: []
  },
  defaultOptions: [],
  create(context) {
    const luminaJsxCheck = checkForLuminaJsx();
    return {
      ImportDeclaration: luminaJsxCheck,
      JSXAttribute(node) {
        if (!luminaJsxCheck.isLuminaJsx || node.name.name !== "ref" || node.value?.type !== AST_NODE_TYPES9.JSXExpressionContainer) {
          return;
        }
        const initializer = node.value.expression;
        if (initializer.type !== AST_NODE_TYPES9.ArrowFunctionExpression && initializer.type !== AST_NODE_TYPES9.FunctionExpression && (initializer.type !== AST_NODE_TYPES9.CallExpression || !isBindThisCallee(initializer.callee))) {
          return;
        }
        context.report({
          messageId: "errorInlineArrow",
          node: initializer
        });
      }
    };
  }
});

// src/plugins/lumina/rules/no-invalid-directives-prop.ts
import { AST_NODE_TYPES as AST_NODE_TYPES10 } from "@typescript-eslint/utils";
var description9 = `directives={} prop value must be an array literal. Documentation: https://qawebgis.esri.com/components/lumina/jsx#lit-directives`;
var noInvalidDirectivesProp = createRule({
  name: "no-invalid-directives-prop",
  meta: {
    docs: {
      description: description9,
      defaultLevel: "error"
    },
    messages: {
      noInvalidDirectivesProp: description9
    },
    type: "problem",
    schema: []
  },
  defaultOptions: [],
  create(context) {
    const luminaJsxCheck = checkForLuminaJsx();
    return {
      ImportDeclaration: luminaJsxCheck,
      JSXAttribute(node) {
        if (!luminaJsxCheck.isLuminaJsx) {
          return;
        }
        if (node.name.name !== "directives") {
          return;
        }
        const array = node.value?.type === AST_NODE_TYPES10.JSXExpressionContainer && node.value.expression.type === AST_NODE_TYPES10.ArrayExpression ? node.value.expression : void 0;
        if (array === void 0 || array.elements.includes(null)) {
          context.report({
            messageId: "noInvalidDirectivesProp",
            node: node.value ?? node
          });
          return;
        }
        array.elements.forEach((element) => {
          if (element?.type === AST_NODE_TYPES10.SpreadElement) {
            context.report({
              messageId: "noInvalidDirectivesProp",
              node: element
            });
          }
        });
      }
    };
  }
});

// src/plugins/lumina/rules/no-jsx-spread.ts
import { AST_NODE_TYPES as AST_NODE_TYPES11 } from "@typescript-eslint/utils";
var description10 = `This spread syntax is not supported. Alternatives: https://qawebgis.esri.com/components/lumina/jsx#spread-attributes`;
var noJsxSpread = createRule({
  name: "no-jsx-spread",
  meta: {
    docs: {
      description: description10,
      defaultLevel: "error"
    },
    messages: {
      noJsxSpread: description10
    },
    type: "problem",
    schema: []
  },
  defaultOptions: [],
  create(context) {
    const luminaJsxCheck = checkForLuminaJsx();
    return {
      ImportDeclaration: luminaJsxCheck,
      JSXSpreadAttribute(node) {
        if (!luminaJsxCheck.isLuminaJsx) {
          return;
        }
        const name = node.parent.name;
        if (
          // Spread syntax is allowed in function calls like <this.render {...props} />
          name.type === AST_NODE_TYPES11.JSXIdentifier && // Spread syntax is allowed in functions
          (name.name.toLowerCase() === name.name || name.name === "DynamicHtmlTag" || name.name === "DynamicSvgTag")
        ) {
          context.report({
            messageId: "noJsxSpread",
            node
          });
        }
      }
    };
  }
});

// src/plugins/lumina/rules/no-listen-in-connected-callback.ts
import { AST_NODE_TYPES as AST_NODE_TYPES12 } from "@typescript-eslint/utils";
var baseDescription3 = `Do not call this.listen()/this.listenOn() in connectedCallback.`;
var description11 = `${baseDescription3}

Instead, call this.listen()/this.listenOn() in constructor(), load() or loaded().

Reason:
this.listen() automatically creates and cleanups the listener on connect/disconnect.
Since connectedCallback can be called multiple times, duplicate listeners may be created.`;
var noListenInConnectedCallback = createRule({
  name: "no-listen-in-connected-callback",
  meta: {
    docs: {
      description: baseDescription3,
      defaultLevel: "error"
    },
    messages: {
      errorListenInConnectedCallback: description11
    },
    type: "problem",
    schema: []
  },
  defaultOptions: [],
  create(context) {
    return {
      CallExpression(node) {
        const isListenCall = node.callee.type === AST_NODE_TYPES12.MemberExpression && node.callee.object.type === AST_NODE_TYPES12.ThisExpression && node.callee.property.type === AST_NODE_TYPES12.Identifier && (node.callee.property.name === "listen" || node.callee.property.name === "listenOn");
        if (!isListenCall) {
          return;
        }
        let hasConnectedCallbackParent = false;
        let currentParent = node.parent;
        while (currentParent) {
          if (currentParent.type === AST_NODE_TYPES12.MethodDefinition) {
            if (currentParent.key.type === AST_NODE_TYPES12.Identifier && currentParent.key.name === "connectedCallback") {
              hasConnectedCallbackParent = true;
            }
            break;
          }
          currentParent = currentParent.parent;
        }
        if (!hasConnectedCallbackParent) {
          return;
        }
        context.report({
          messageId: "errorListenInConnectedCallback",
          node
        });
      }
    };
  }
});

// src/plugins/lumina/rules/no-non-component-exports.ts
import { AST_NODE_TYPES as AST_NODE_TYPES13 } from "@typescript-eslint/utils";
var description12 = `To ensure Hot Module Replacement (HMR) works correctly, the file that defines the Lumina component must not export anything other than the component. Exceptions: type-only exports, and the \`exportsForTests\` object for exposing additional things for usages in tests only`;
var noNonComponentExports = createRule({
  name: "no-non-component-exports",
  meta: {
    docs: {
      description: description12,
      defaultLevel: "warn"
    },
    messages: {
      noNonComponentExports: description12,
      noDefaultExports: `Default exports are not allowed in files that export Lumina component - only named exports are allowed. ${description12}`,
      noExportAll: `\`export *\` exports are not allowed in files that export Lumina component - only named exports are allowed. ${description12}`
    },
    type: "problem",
    schema: []
  },
  defaultOptions: [],
  create(context) {
    const declaredComponents = /* @__PURE__ */ new Set();
    const hasLuminaDeclarations = context.sourceCode.text.includes("interface DeclareElements");
    return {
      TSModuleDeclaration(node) {
        const luminaDeclarationInterface = extractDeclareElementsInterface(node);
        if (luminaDeclarationInterface === void 0) {
          return;
        }
        luminaDeclarationInterface.body.body.forEach((member) => {
          if (member.type !== AST_NODE_TYPES13.TSPropertySignature || member.computed) {
            return;
          }
          const type = member.typeAnnotation?.typeAnnotation;
          if (type?.type !== AST_NODE_TYPES13.TSTypeReference || type.typeName.type !== AST_NODE_TYPES13.Identifier) {
            return;
          }
          const className = type.typeName.name;
          declaredComponents.add(className);
        });
      },
      ExportNamedDeclaration(node) {
        if (!hasLuminaDeclarations && declaredComponents.size === 0) {
          return;
        }
        if (node.exportKind === "type") {
          return;
        }
        if (node.declaration?.type === AST_NODE_TYPES13.VariableDeclaration) {
          const isExportsForTests = node.declaration.declarations.every(
            (declaration) => declaration.id.type === AST_NODE_TYPES13.Identifier && declaration.id.name === "exportsForTests"
          );
          if (isExportsForTests) {
            return;
          }
        } else if (node.declaration?.type === AST_NODE_TYPES13.FunctionDeclaration) {
          const isExportsForTests = node.declaration.id?.name === "exportsForTests";
          if (isExportsForTests) {
            return;
          }
        } else if (
          // Type-only constructs
          node.declaration?.type === AST_NODE_TYPES13.TSDeclareFunction || node.declaration?.type === AST_NODE_TYPES13.TSInterfaceDeclaration || node.declaration?.type === AST_NODE_TYPES13.TSTypeAliasDeclaration
        ) {
          return;
        } else if (node.declaration?.type === AST_NODE_TYPES13.ClassDeclaration) {
          const isComponent = declaredComponents.has(node.declaration.id?.name ?? "");
          if (isComponent) {
            return;
          }
        }
        context.report({
          node,
          messageId: "noNonComponentExports"
        });
      },
      ExportDefaultDeclaration(node) {
        if (!hasLuminaDeclarations && declaredComponents.size === 0) {
          return;
        }
        context.report({
          node,
          messageId: "noDefaultExports"
        });
      },
      ExportAllDeclaration(node) {
        if (!hasLuminaDeclarations && declaredComponents.size === 0) {
          return;
        }
        if (node.exportKind === "type") {
          return;
        }
        context.report({
          node,
          messageId: "noExportAll"
        });
      }
    };
  }
});

// src/plugins/lumina/rules/no-property-name-start-with-on.ts
import { AST_NODE_TYPES as AST_NODE_TYPES14 } from "@typescript-eslint/utils";
var description13 = `Do not start public property names with "on" as that can confuse frameworks into thinking this property is an event`;
var noPropertyNameStartWithOn = createRule({
  name: "no-property-name-start-with-on",
  meta: {
    docs: {
      description: description13,
      defaultLevel: "error"
    },
    messages: {
      noPropertyNameStartWithOn: description13
    },
    type: "problem",
    schema: []
  },
  defaultOptions: [],
  create(context) {
    return {
      PropertyDefinition(node) {
        const isPublicProperty = hasDecorator(node, "property");
        if (!isPublicProperty) {
          return;
        }
        const propertyName = node.key.type === AST_NODE_TYPES14.Identifier ? node.key.name : node.key.type === AST_NODE_TYPES14.Literal ? node.key.value : void 0;
        if (typeof propertyName !== "string") {
          return;
        }
        if (!propertyName.startsWith("on")) {
          return;
        }
        const comments = context.sourceCode.getCommentsBefore(node);
        const isDeprecated = comments.some((comment) => comment.value.includes("@deprecated"));
        if (isDeprecated) {
          return;
        }
        context.report({
          messageId: "noPropertyNameStartWithOn",
          node: node.key
        });
      }
    };
  }
});

// src/plugins/lumina/rules/no-render-false.ts
import { AST_NODE_TYPES as AST_NODE_TYPES15, ESLintUtils as ESLintUtils4 } from "@typescript-eslint/utils";

// src/plugins/lumina/utils/checker.ts
import ts3 from "typescript";
var litTemplateResult = "TemplateResult";
var explicitJsxTypeName = "JsxNode";
var implicitJsxTypeName = "Element";
var implicitJsxParentName = "LuminaJsx";
function isLuminaJsxType(type) {
  for (const declaration of type.aliasSymbol?.declarations ?? []) {
    if (!ts3.isTypeAliasDeclaration(declaration)) {
      continue;
    }
    const typeName = declaration.name.escapedText;
    if (typeName === litTemplateResult || typeName === explicitJsxTypeName) {
      return true;
    }
    if (typeName !== implicitJsxTypeName) {
      continue;
    }
    const grandParent = declaration.parent?.parent;
    if (!ts3.isModuleDeclaration(grandParent)) {
      continue;
    }
    const symbol = grandParent.symbol;
    if (symbol?.escapedName === implicitJsxParentName) {
      return true;
    }
  }
  return false;
}

// src/plugins/lumina/rules/no-render-false.ts
var baseDescription4 = `Avoid accidentally rendering "false" to the screen (Lit stringifies booleans, rather than drop them like React/Stencil).`;
var description14 = `${baseDescription4}

Lumina automatically handles some cases where "false" may get rendered to the screen, but the pattern this code is using is not handled.`;
var noRenderFalse = createRule({
  name: "no-render-false",
  meta: {
    docs: {
      description: baseDescription4,
      defaultLevel: "warn"
    },
    messages: {
      errorFalseRendered: description14
    },
    type: "problem",
    schema: [],
    fixable: "code"
  },
  defaultOptions: [],
  create(context) {
    const services = ESLintUtils4.getParserServices(context);
    return {
      LogicalExpression(node) {
        if (node.operator !== "&&") {
          return;
        }
        const type = services.getTypeAtLocation(node.right);
        if (!isLuminaJsxType(type)) {
          return;
        }
        if (node.parent.type === AST_NODE_TYPES15.JSXExpressionContainer) {
          return;
        }
        const right = unwrapExpression(node.right);
        if (right.type === AST_NODE_TYPES15.JSXElement) {
          return;
        }
        if (node.parent.type === AST_NODE_TYPES15.LogicalExpression) {
          return;
        }
        context.report({
          messageId: "errorFalseRendered",
          node,
          fix(fixer) {
            const leftText = context.sourceCode.getText(node.left);
            const rightText = context.sourceCode.getText(node.right);
            const replacement = `${leftText} ? ${rightText} : ""`;
            return fixer.replaceText(node, replacement);
          }
        });
      }
    };
  }
});

// src/plugins/lumina/rules/no-unnecessary-attribute-name.ts
import { AST_NODE_TYPES as AST_NODE_TYPES16 } from "@typescript-eslint/utils";
import { camelToKebab } from "@arcgis/components-utils";
var description15 = 'There is no need for { attribute: "name" } in @property() when attribute name is trivially inferrable from the property name';
var noUnnecessaryAttributeName = createRule({
  name: "no-unnecessary-attribute-name",
  meta: {
    docs: {
      description: description15,
      defaultLevel: "warn"
    },
    messages: {
      noUnnecessaryAttributeName: description15
    },
    type: "suggestion",
    schema: [],
    fixable: "code"
  },
  defaultOptions: [],
  create(context) {
    return {
      Decorator(decorator) {
        const part = parsePropertyDecorator(decorator);
        if (part === void 0) {
          return;
        }
        const { properties } = part;
        const property = decorator.parent;
        if (property?.type !== AST_NODE_TYPES16.MethodDefinition && property?.type !== AST_NODE_TYPES16.PropertyDefinition) {
          return;
        }
        const attributeOption = getProperty(properties, "attribute");
        const attributeValue = attributeOption?.type === AST_NODE_TYPES16.Literal && typeof attributeOption.value === "string" ? attributeOption.value : void 0;
        if (attributeOption === void 0 || attributeValue === void 0) {
          return;
        }
        const propertyName = getName(property);
        if (propertyName === void 0) {
          return;
        }
        const inferredName = camelToKebab(propertyName);
        if (attributeValue === inferredName) {
          context.report({
            node: attributeOption,
            messageId: "noUnnecessaryAttributeName",
            fix(fixer) {
              const nextToken = context.sourceCode.getTokenAfter(attributeOption.parent);
              const isTrailingComma = nextToken && nextToken.value === ",";
              return isTrailingComma ? fixer.removeRange([attributeOption.parent.range[0], nextToken.range[1]]) : fixer.remove(attributeOption.parent);
            }
          });
        }
      }
    };
  }
});

// src/plugins/lumina/rules/no-unnecessary-bind-this.ts
import { AST_NODE_TYPES as AST_NODE_TYPES17 } from "@typescript-eslint/utils";
var description16 = `.bind(this) is not necessary in Lit's event listener callbacks and ref callbacks as it is handled automatically.`;
var noUnnecessaryBindThis = createRule({
  name: "no-unnecessary-bind-this",
  meta: {
    docs: {
      description: description16,
      defaultLevel: "warn"
    },
    messages: {
      noUnnecessaryBindThis: description16
    },
    type: "problem",
    schema: [],
    fixable: "code"
  },
  defaultOptions: [],
  create(context) {
    const luminaJsxCheck = checkForLuminaJsx();
    return {
      ImportDeclaration: luminaJsxCheck,
      JSXExpressionContainer(node) {
        if (!luminaJsxCheck.isLuminaJsx || node.parent.type !== AST_NODE_TYPES17.JSXAttribute || node.parent.name.type !== AST_NODE_TYPES17.JSXIdentifier) {
          return;
        }
        const name = node.parent.name.name;
        const isAutoBindable = name.startsWith("on") || name === "ref";
        if (!isAutoBindable) {
          return;
        }
        const expression = node.expression.type === AST_NODE_TYPES17.ChainExpression ? node.expression.expression : node.expression;
        const isCallWithThis = (
          // expression(...)
          expression.type === AST_NODE_TYPES17.CallExpression && // expression(expression)
          expression.arguments.length === 1 && // expression(this)
          expression.arguments[0].type === AST_NODE_TYPES17.ThisExpression
        );
        if (!isCallWithThis) {
          return;
        }
        const callee = expression.callee;
        if (!isBindThisCallee(callee)) {
          return;
        }
        const tagName = context.sourceCode.getAncestors(node.parent).find((ancestor) => ancestor.type === AST_NODE_TYPES17.JSXOpeningElement)?.name;
        const tagNameString = tagName?.type === AST_NODE_TYPES17.JSXIdentifier ? tagName.name : void 0;
        if (tagNameString === void 0) {
          return;
        }
        const isHtmlElement = tagNameString.startsWith(tagNameString.charAt(0).toLowerCase()) || tagNameString === "DynamicHtmlTag" || tagNameString === "DynamicSvgTag";
        if (!isHtmlElement) {
          return;
        }
        context.report({
          messageId: "noUnnecessaryBindThis",
          node: callee.property,
          fix(fixer) {
            return fixer.replaceText(expression, context.sourceCode.getText(callee.object));
          }
        });
      }
    };
  }
});

// src/plugins/lumina/rules/no-unnecessary-key.ts
import { AST_NODE_TYPES as AST_NODE_TYPES18 } from "@typescript-eslint/utils";
var description17 = `In most cases, key={index} is not necessary in Lumina in .map(). Details: https://qawebgis.esri.com/components/lumina/jsx#key-prop`;
var noUnnecessaryKey = createRule({
  name: "no-unnecessary-key",
  meta: {
    docs: {
      description: description17,
      defaultLevel: "warn"
    },
    messages: {
      noUnnecessaryKey: description17
    },
    type: "suggestion",
    schema: [],
    fixable: "code"
  },
  defaultOptions: [],
  create(context) {
    const luminaJsxCheck = checkForLuminaJsx();
    return {
      ImportDeclaration: luminaJsxCheck,
      JSXExpressionContainer(node) {
        if (!luminaJsxCheck.isLuminaJsx) {
          return;
        }
        const keyValue = node.expression;
        if (keyValue.type !== AST_NODE_TYPES18.Identifier) {
          return;
        }
        const keyAttribute = node.parent;
        if (keyAttribute?.type !== AST_NODE_TYPES18.JSXAttribute || keyAttribute.name.type !== AST_NODE_TYPES18.JSXIdentifier || keyAttribute.name.name !== "key") {
          return;
        }
        const mapArrowFunction = context.sourceCode.getAncestors(keyAttribute).find(
          (ancestor) => ancestor.type === AST_NODE_TYPES18.ArrowFunctionExpression && ancestor.parent?.type === AST_NODE_TYPES18.CallExpression && ancestor.parent?.callee.type === AST_NODE_TYPES18.MemberExpression && ancestor.parent?.callee.property.type === AST_NODE_TYPES18.Identifier && ancestor.parent?.callee.property.name === "map"
        );
        if (mapArrowFunction === void 0) {
          return;
        }
        const keyParameter = mapArrowFunction.params.at(1);
        if (keyParameter?.type !== AST_NODE_TYPES18.Identifier || keyParameter.name !== keyValue.name) {
          return;
        }
        context.report({
          messageId: "noUnnecessaryKey",
          node: keyAttribute,
          fix(fixer) {
            const usesIndexOutsideKey = Array.from(
              context.sourceCode.getText(mapArrowFunction.body).matchAll(new RegExp(`\\b${keyValue.name}\\b`, "ug"))
            ).length > 1;
            const withoutAttribute = fixer.remove(keyAttribute);
            if (usesIndexOutsideKey || mapArrowFunction.params.length > 2) {
              return withoutAttribute;
            } else {
              return [withoutAttribute, fixer.remove(keyParameter)];
            }
          }
        });
      }
    };
  }
});

// src/plugins/lumina/rules/tag-name-rules.ts
import { AST_NODE_TYPES as AST_NODE_TYPES19 } from "@typescript-eslint/utils";
var description18 = `Validate component tag name`;
var defaultOptions2 = [
  {
    namespaces: ["arcgis-"]
  }
];
var tagNameRules = createRule({
  name: "tag-name-rules",
  meta: {
    docs: {
      description: description18,
      defaultLevel: "error"
    },
    messages: {
      requireNamespace: "Custom element tag names in this project must start with one of the following namespaces: {{namespaces}}",
      noComputedTagName: "Computed tag names are not allowed",
      noNonStringTagName: 'Tag names must be strings like "arcgis-click" rather than numbers',
      noTagNameIdentifier: "Tag name must include a dash",
      unexpectedDeclareElementsEntry: "Unexpected entry in declare elements interface. Expected a property signature",
      unexpectedDeclarationType: "Unexpected declaration type. Expected component class identifier",
      duplicateDeclaration: "The same component may only be assigned to one class name. If you need  multiple tag names, consider sub-classing the component",
      missingClassDeclaration: "Missing class declaration",
      unexpectedTypeArguments: "Unexpected type arguments in the component tag name declaration. Type arguments should be specified in the component class declaration",
      reservedTagName: "This is a reserved html element tag name. Declaring components with this name is forbidden by the custom elements specification.",
      duplicateDeclareGlobal: `There should only be a single "declare global" block in a file. Declaring multiple components in a single file is supported, but they should share the same "declare global {" block. Example:
declare global {
  interface DeclareElements {
    "arcgis-test1": ArcgisTest1;
    "arcgis-test2": ArcgisTest2;
  }
}`,
      mustSubclass: "Lumina component is required to subclass LitElement or a subclass of LitElement",
      mustNotSubclassHtmlElement: "Lumina component is not allowed to subclass HTMLElement classes directly. Subclass LitElement or a subclass of LitElement instead",
      tagNameClassNameMismatch: 'The custom element tag name "{{tagName}}" does not seem to match the class name it is assigned to: "{{className}}". Make sure tag name and class name use the same characters in the same order (case insensitive, hyphens removed). {{namespaceNotice}}',
      missingHyphen: "Custom element tag names need to include a hyphen",
      lowercaseTagName: "For consistency, custom element tag names should be defined in lowercase",
      invalidTagName: "Potentially invalid custom element name. Expected tag name to match regex: {{regex}}. This regex is stricter than what the custom elements spec allows in order to catch possible typos. Please contact Lumina maintainers if you need to loosen this check."
    },
    type: "problem",
    schema: [
      {
        type: "object",
        properties: {
          namespaces: {
            type: "array",
            items: {
              type: "string"
            }
          }
        },
        additionalProperties: false
      }
    ],
    fixable: "code"
  },
  defaultOptions: defaultOptions2,
  create(context, options) {
    const declaredComponents = /* @__PURE__ */ new Map();
    let seenDeclareGlobal = false;
    return {
      "TSModuleDeclaration"(node) {
        const luminaDeclarationInterface = extractDeclareElementsInterface(node);
        if (luminaDeclarationInterface === void 0) {
          return;
        }
        if (seenDeclareGlobal) {
          context.report({
            messageId: "duplicateDeclareGlobal",
            node
          });
          return;
        }
        seenDeclareGlobal = true;
        luminaDeclarationInterface.body.body.forEach((member) => {
          if (member.type !== AST_NODE_TYPES19.TSPropertySignature) {
            context.report({
              messageId: "unexpectedDeclareElementsEntry",
              node: member
            });
            return;
          }
          if (member.computed) {
            context.report({
              messageId: "noComputedTagName",
              node: member.key
            });
            return;
          }
          if (member.key.type === AST_NODE_TYPES19.Identifier) {
            context.report({
              messageId: "noTagNameIdentifier",
              node: member.key
            });
            return;
          }
          if (typeof member.key.value !== "string") {
            context.report({
              messageId: "noNonStringTagName",
              node: member.key
            });
            return;
          }
          const tagName = member.key.value;
          let namespaceFreeTagName = tagName;
          const namespaces = options[0].namespaces;
          if (namespaces.length > 0) {
            const namespace = namespaces.find((ns) => tagName.startsWith(ns));
            if (namespace === void 0) {
              context.report({
                messageId: "requireNamespace",
                node: member.key,
                data: {
                  namespaces: namespaces.join(", ")
                }
              });
              return;
            } else {
              namespaceFreeTagName = tagName.slice(namespace.length);
            }
          }
          if (!tagName.includes("-")) {
            context.report({
              messageId: "missingHyphen",
              node: member.key
            });
            return;
          }
          if (tagName.toLowerCase() !== tagName) {
            context.report({
              messageId: "lowercaseTagName",
              node: member.key
            });
            return;
          }
          if (!reCustomElementName.test(tagName)) {
            context.report({
              messageId: "invalidTagName",
              node: member.key,
              data: {
                regex: reCustomElementName.toString()
              }
            });
            return;
          }
          if (blockListedCustomElementNames.has(tagName)) {
            context.report({
              messageId: "reservedTagName",
              node: member.key
            });
            return;
          }
          const type = member.typeAnnotation?.typeAnnotation;
          if (type?.type !== AST_NODE_TYPES19.TSTypeReference || type.typeName.type !== AST_NODE_TYPES19.Identifier) {
            context.report({
              messageId: "unexpectedDeclarationType",
              node: type ?? member
            });
            return;
          }
          if (type.typeArguments !== void 0) {
            context.report({
              messageId: "unexpectedTypeArguments",
              node: type
            });
            return;
          }
          const className = type.typeName.name;
          const classNameFromTagName = tagNameToNormalizedClassName(tagName);
          const classNameFromShortTagName = tagNameToNormalizedClassName(namespaceFreeTagName);
          if (classNameFromTagName !== className.toLowerCase() && classNameFromShortTagName !== className.toLowerCase()) {
            context.report({
              messageId: "tagNameClassNameMismatch",
              node: type.typeName,
              data: {
                tagName,
                className,
                namespaceNotice: namespaces.length > 0 ? `In addition, the following tag name prefixes are expected: ${namespaces.join(", ")}` : ""
              }
            });
            return;
          }
          if (declaredComponents.has(className)) {
            context.report({
              messageId: "duplicateDeclaration",
              node: type.typeName
            });
            return;
          }
          declaredComponents.set(className, type.typeName);
        });
      },
      "ClassDeclaration"(node) {
        if (node.id !== null && declaredComponents.has(node.id.name)) {
          declaredComponents.delete(node.id.name);
          if (node.superClass === null) {
            context.report({
              messageId: "mustSubclass",
              node
            });
          } else if (node.superClass.type === AST_NODE_TYPES19.Identifier && node.superClass.name.startsWith("HTML") && node.superClass.name.endsWith("Element")) {
            context.report({
              messageId: "mustNotSubclassHtmlElement",
              node
            });
          }
        }
      },
      "Program:exit"() {
        for (const identifier of declaredComponents.values()) {
          context.report({
            messageId: "missingClassDeclaration",
            node: identifier
          });
        }
      }
    };
  }
});
var blockListedCustomElementNames = /* @__PURE__ */ new Set([
  "annotation-xml",
  "color-profile",
  "font-face",
  "font-face-src",
  "font-face-uri",
  "font-face-format",
  "font-face-name",
  "missing-glyph"
]);
var tagNameToNormalizedClassName = (tagName) => tagName.replaceAll("-", "").toLowerCase();
var reCustomElementName = /^[a-z]+(?:-[a-z\d]+)+$/u;

// src/plugins/lumina/index.ts
var lumina_default = makeEslintPlugin("lumina", {
  "add-missing-jsx-import": addMissingJsxImport,
  "auto-add-type": autoAddType,
  "component-placement-rules": componentPlacementRules,
  "consistent-event-naming": consistentEventNaming,
  "decorators-context": decoratorsContext,
  "member-ordering": memberOrdering,
  "no-ignore-jsdoc-tag": noIgnoreJsDocTag,
  "no-incorrect-dynamic-tag-name": noIncorrectDynamicTagName,
  "no-inline-arrow-in-ref": noInlineArrowInRef,
  "no-invalid-directives-prop": noInvalidDirectivesProp,
  "no-jsx-spread": noJsxSpread,
  "no-listen-in-connected-callback": noListenInConnectedCallback,
  "no-non-component-exports": noNonComponentExports,
  "no-property-name-start-with-on": noPropertyNameStartWithOn,
  "no-render-false": noRenderFalse,
  "no-unnecessary-attribute-name": noUnnecessaryAttributeName,
  "no-unnecessary-bind-this": noUnnecessaryBindThis,
  "no-unnecessary-key": noUnnecessaryKey,
  "tag-name-rules": tagNameRules
});

export {
  lumina_default
};
